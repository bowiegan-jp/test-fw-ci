{"uid":"d0a7062ccf35f397","name":"test_login_failed[chrome]","fullName":"tests.ui.auth.test_login.TestLogin#test_login_failed","historyId":"b602c7da2fb125d5a7ad979882328b15","time":{"start":1658375440128,"stop":1658375440128,"duration":0},"status":"broken","statusMessage":"selenium.common.exceptions.WebDriverException: Message: 'chromedriver' executable needs to be in PATH. Please see https://sites.google.com/a/chromium.org/chromedriver/home","statusTrace":"self = <selenium.webdriver.chrome.service.Service object at 0x7fc9f5d96490>\n\n    def start(self):\n        \"\"\"\n        Starts the Service.\n    \n        :Exceptions:\n         - WebDriverException : Raised either when it can't start the service\n           or when it can't connect to the service\n        \"\"\"\n        try:\n            cmd = [self.path]\n            cmd.extend(self.command_line_args())\n            self.process = subprocess.Popen(cmd, env=self.env,\n                                            close_fds=platform.system() != 'Windows',\n                                            stdout=self.log_file,\n                                            stderr=self.log_file,\n>                                           stdin=PIPE)\n\n/opt/hostedtoolcache/Python/3.7.13/x64/lib/python3.7/site-packages/selenium/webdriver/common/service.py:76: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <subprocess.Popen object at 0x7fc9f5d96150>\nargs = ['chromedriver', '--port=60403'], bufsize = -1, executable = None\nstdin = -1, stdout = -3, stderr = -3, preexec_fn = None, close_fds = True\nshell = False, cwd = None\nenv = environ({'SHELL': '/bin/bash', 'GITHUB_WORKSPACE': '/var/snap/amazon-ssm-agent/5656/actions-runner/_work/test-fw-ci/te..._WAIT_TIME': '30', 'PYTEST_CURRENT_TEST': 'tests/ui/auth/test_login.py::TestLogin::test_login_failed[chrome] (setup)'})\nuniversal_newlines = None, startupinfo = None, creationflags = 0\nrestore_signals = True, start_new_session = False, pass_fds = ()\n\n    def __init__(self, args, bufsize=-1, executable=None,\n                 stdin=None, stdout=None, stderr=None,\n                 preexec_fn=None, close_fds=True,\n                 shell=False, cwd=None, env=None, universal_newlines=None,\n                 startupinfo=None, creationflags=0,\n                 restore_signals=True, start_new_session=False,\n                 pass_fds=(), *, encoding=None, errors=None, text=None):\n        \"\"\"Create new Popen instance.\"\"\"\n        _cleanup()\n        # Held while anything is calling waitpid before returncode has been\n        # updated to prevent clobbering returncode if wait() or poll() are\n        # called from multiple threads at once.  After acquiring the lock,\n        # code must re-check self.returncode to see if another thread just\n        # finished a waitpid() call.\n        self._waitpid_lock = threading.Lock()\n    \n        self._input = None\n        self._communication_started = False\n        if bufsize is None:\n            bufsize = -1  # Restore default\n        if not isinstance(bufsize, int):\n            raise TypeError(\"bufsize must be an integer\")\n    \n        if _mswindows:\n            if preexec_fn is not None:\n                raise ValueError(\"preexec_fn is not supported on Windows \"\n                                 \"platforms\")\n        else:\n            # POSIX\n            if pass_fds and not close_fds:\n                warnings.warn(\"pass_fds overriding close_fds.\", RuntimeWarning)\n                close_fds = True\n            if startupinfo is not None:\n                raise ValueError(\"startupinfo is only supported on Windows \"\n                                 \"platforms\")\n            if creationflags != 0:\n                raise ValueError(\"creationflags is only supported on Windows \"\n                                 \"platforms\")\n    \n        self.args = args\n        self.stdin = None\n        self.stdout = None\n        self.stderr = None\n        self.pid = None\n        self.returncode = None\n        self.encoding = encoding\n        self.errors = errors\n    \n        # Validate the combinations of text and universal_newlines\n        if (text is not None and universal_newlines is not None\n            and bool(universal_newlines) != bool(text)):\n            raise SubprocessError('Cannot disambiguate when both text '\n                                  'and universal_newlines are supplied but '\n                                  'different. Pass one or the other.')\n    \n        # Input and output objects. The general principle is like\n        # this:\n        #\n        # Parent                   Child\n        # ------                   -----\n        # p2cwrite   ---stdin--->  p2cread\n        # c2pread    <--stdout---  c2pwrite\n        # errread    <--stderr---  errwrite\n        #\n        # On POSIX, the child objects are file descriptors.  On\n        # Windows, these are Windows file handles.  The parent objects\n        # are file descriptors on both platforms.  The parent objects\n        # are -1 when not using PIPEs. The child objects are -1\n        # when not redirecting.\n    \n        (p2cread, p2cwrite,\n         c2pread, c2pwrite,\n         errread, errwrite) = self._get_handles(stdin, stdout, stderr)\n    \n        # We wrap OS handles *before* launching the child, otherwise a\n        # quickly terminating child could make our fds unwrappable\n        # (see #8458).\n    \n        if _mswindows:\n            if p2cwrite != -1:\n                p2cwrite = msvcrt.open_osfhandle(p2cwrite.Detach(), 0)\n            if c2pread != -1:\n                c2pread = msvcrt.open_osfhandle(c2pread.Detach(), 0)\n            if errread != -1:\n                errread = msvcrt.open_osfhandle(errread.Detach(), 0)\n    \n        self.text_mode = encoding or errors or text or universal_newlines\n    \n        # How long to resume waiting on a child after the first ^C.\n        # There is no right value for this.  The purpose is to be polite\n        # yet remain good for interactive users trying to exit a tool.\n        self._sigint_wait_secs = 0.25  # 1/xkcd221.getRandomNumber()\n    \n        self._closed_child_pipe_fds = False\n    \n        try:\n            if p2cwrite != -1:\n                self.stdin = io.open(p2cwrite, 'wb', bufsize)\n                if self.text_mode:\n                    self.stdin = io.TextIOWrapper(self.stdin, write_through=True,\n                            line_buffering=(bufsize == 1),\n                            encoding=encoding, errors=errors)\n            if c2pread != -1:\n                self.stdout = io.open(c2pread, 'rb', bufsize)\n                if self.text_mode:\n                    self.stdout = io.TextIOWrapper(self.stdout,\n                            encoding=encoding, errors=errors)\n            if errread != -1:\n                self.stderr = io.open(errread, 'rb', bufsize)\n                if self.text_mode:\n                    self.stderr = io.TextIOWrapper(self.stderr,\n                            encoding=encoding, errors=errors)\n    \n            self._execute_child(args, executable, preexec_fn, close_fds,\n                                pass_fds, cwd, env,\n                                startupinfo, creationflags, shell,\n                                p2cread, p2cwrite,\n                                c2pread, c2pwrite,\n                                errread, errwrite,\n>                               restore_signals, start_new_session)\n\n/opt/hostedtoolcache/Python/3.7.13/x64/lib/python3.7/subprocess.py:800: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <subprocess.Popen object at 0x7fc9f5d96150>\nargs = ['chromedriver', '--port=60403'], executable = b'chromedriver'\npreexec_fn = None, close_fds = True, pass_fds = (), cwd = None\nenv = environ({'SHELL': '/bin/bash', 'GITHUB_WORKSPACE': '/var/snap/amazon-ssm-agent/5656/actions-runner/_work/test-fw-ci/te..._WAIT_TIME': '30', 'PYTEST_CURRENT_TEST': 'tests/ui/auth/test_login.py::TestLogin::test_login_failed[chrome] (setup)'})\nstartupinfo = None, creationflags = 0, shell = False, p2cread = 11\np2cwrite = 12, c2pread = -1, c2pwrite = 13, errread = -1, errwrite = 13\nrestore_signals = True, start_new_session = False\n\n    def _execute_child(self, args, executable, preexec_fn, close_fds,\n                       pass_fds, cwd, env,\n                       startupinfo, creationflags, shell,\n                       p2cread, p2cwrite,\n                       c2pread, c2pwrite,\n                       errread, errwrite,\n                       restore_signals, start_new_session):\n        \"\"\"Execute program (POSIX version)\"\"\"\n    \n        if isinstance(args, (str, bytes)):\n            args = [args]\n        else:\n            args = list(args)\n    \n        if shell:\n            # On Android the default shell is at '/system/bin/sh'.\n            unix_shell = ('/system/bin/sh' if\n                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')\n            args = [unix_shell, \"-c\"] + args\n            if executable:\n                args[0] = executable\n    \n        if executable is None:\n            executable = args[0]\n        orig_executable = executable\n    \n        # For transferring possible exec failure from child to parent.\n        # Data format: \"exception name:hex errno:description\"\n        # Pickle is not used; it is complex and involves memory allocation.\n        errpipe_read, errpipe_write = os.pipe()\n        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.\n        low_fds_to_close = []\n        while errpipe_write < 3:\n            low_fds_to_close.append(errpipe_write)\n            errpipe_write = os.dup(errpipe_write)\n        for low_fd in low_fds_to_close:\n            os.close(low_fd)\n        try:\n            try:\n                # We must avoid complex work that could involve\n                # malloc or free in the child process to avoid\n                # potential deadlocks, thus we do all this here.\n                # and pass it to fork_exec()\n    \n                if env is not None:\n                    env_list = []\n                    for k, v in env.items():\n                        k = os.fsencode(k)\n                        if b'=' in k:\n                            raise ValueError(\"illegal environment variable name\")\n                        env_list.append(k + b'=' + os.fsencode(v))\n                else:\n                    env_list = None  # Use execv instead of execve.\n                executable = os.fsencode(executable)\n                if os.path.dirname(executable):\n                    executable_list = (executable,)\n                else:\n                    # This matches the behavior of os._execvpe().\n                    executable_list = tuple(\n                        os.path.join(os.fsencode(dir), executable)\n                        for dir in os.get_exec_path(env))\n                fds_to_keep = set(pass_fds)\n                fds_to_keep.add(errpipe_write)\n                self.pid = _posixsubprocess.fork_exec(\n                        args, executable_list,\n                        close_fds, tuple(sorted(map(int, fds_to_keep))),\n                        cwd, env_list,\n                        p2cread, p2cwrite, c2pread, c2pwrite,\n                        errread, errwrite,\n                        errpipe_read, errpipe_write,\n                        restore_signals, start_new_session, preexec_fn)\n                self._child_created = True\n            finally:\n                # be sure the FD is closed no matter what\n                os.close(errpipe_write)\n    \n            # self._devnull is not always defined.\n            devnull_fd = getattr(self, '_devnull', None)\n            if p2cread != -1 and p2cwrite != -1 and p2cread != devnull_fd:\n                os.close(p2cread)\n            if c2pwrite != -1 and c2pread != -1 and c2pwrite != devnull_fd:\n                os.close(c2pwrite)\n            if errwrite != -1 and errread != -1 and errwrite != devnull_fd:\n                os.close(errwrite)\n            if devnull_fd is not None:\n                os.close(devnull_fd)\n            # Prevent a double close of these fds from __init__ on error.\n            self._closed_child_pipe_fds = True\n    \n            # Wait for exec to fail or succeed; possibly raising an\n            # exception (limited in size)\n            errpipe_data = bytearray()\n            while True:\n                part = os.read(errpipe_read, 50000)\n                errpipe_data += part\n                if not part or len(errpipe_data) > 50000:\n                    break\n        finally:\n            # be sure the FD is closed no matter what\n            os.close(errpipe_read)\n    \n        if errpipe_data:\n            try:\n                pid, sts = os.waitpid(self.pid, 0)\n                if pid == self.pid:\n                    self._handle_exitstatus(sts)\n                else:\n                    self.returncode = sys.maxsize\n            except ChildProcessError:\n                pass\n    \n            try:\n                exception_name, hex_errno, err_msg = (\n                        errpipe_data.split(b':', 2))\n                # The encoding here should match the encoding\n                # written in by the subprocess implementations\n                # like _posixsubprocess\n                err_msg = err_msg.decode()\n            except ValueError:\n                exception_name = b'SubprocessError'\n                hex_errno = b'0'\n                err_msg = 'Bad exception data from child: {!r}'.format(\n                              bytes(errpipe_data))\n            child_exception_type = getattr(\n                    builtins, exception_name.decode('ascii'),\n                    SubprocessError)\n            if issubclass(child_exception_type, OSError) and hex_errno:\n                errno_num = int(hex_errno, 16)\n                child_exec_never_called = (err_msg == \"noexec\")\n                if child_exec_never_called:\n                    err_msg = \"\"\n                    # The error must be from chdir(cwd).\n                    err_filename = cwd\n                else:\n                    err_filename = orig_executable\n                if errno_num != 0:\n                    err_msg = os.strerror(errno_num)\n                    if errno_num == errno.ENOENT:\n                        err_msg += ': ' + repr(err_filename)\n>               raise child_exception_type(errno_num, err_msg, err_filename)\nE               FileNotFoundError: [Errno 2] No such file or directory: 'chromedriver': 'chromedriver'\n\n/opt/hostedtoolcache/Python/3.7.13/x64/lib/python3.7/subprocess.py:1551: FileNotFoundError\n\nDuring handling of the above exception, another exception occurred:\n\nrequest = <SubRequest 'browser' for <Function test_login_failed[chrome]>>\ncfg = <config.Config object at 0x7fc9f5d9fd90>\n\n    @allure.step(\"Initiate browser instance\")\n    @pytest.fixture(params=Config.BROWSERS, scope=\"class\")\n    def browser(request, cfg):\n        SUPPORTED_BROWSERS = [\"chrome\", \"firefox\"]\n        PROXY = cfg.HTTP_PROXY\n        remote = request.config.option.remote\n    \n        browser = request.param.lower()\n        if browser not in SUPPORTED_BROWSERS:\n            pytest.skip(f\"Unsupported browser type: {browser}\")\n        if browser == \"chrome\":\n            options = chrome_opt()\n            options.add_argument(\"--ignore-ssl-errors=yes\")\n            options.add_argument(\"--ignore-certificate-errors\")\n            if PROXY:\n                options.add_argument('--proxy-server=http://%s' % f'{PROXY}')\n            options.add_argument(\"--kiosk\")\n            if cfg.HEADLESS_TEST:\n                options.headless = True\n                options.add_argument(\"--kiosk\")\n            if remote:\n                dc = webdriver.DesiredCapabilities.CHROME.copy()\n                dc.update({\n                    \"name\": request.node.name,\n                    \"browserName\": \"chrome\",\n                    \"browserVersion\": \"90.0\",\n                    \"selenoid:options\": {\n                        \"enableVNC\": True,\n                        \"enableVideo\": False\n                    }\n                })\n                web_driver = webdriver.Remote(command_executor=cfg.REMOTE_GRID_URL, desired_capabilities=dc, options=options)\n            else:\n>               web_driver = webdriver.Chrome(options=options)\n\ntests/conftest.py:87: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/opt/hostedtoolcache/Python/3.7.13/x64/lib/python3.7/site-packages/selenium/webdriver/chrome/webdriver.py:73: in __init__\n    self.service.start()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <selenium.webdriver.chrome.service.Service object at 0x7fc9f5d96490>\n\n    def start(self):\n        \"\"\"\n        Starts the Service.\n    \n        :Exceptions:\n         - WebDriverException : Raised either when it can't start the service\n           or when it can't connect to the service\n        \"\"\"\n        try:\n            cmd = [self.path]\n            cmd.extend(self.command_line_args())\n            self.process = subprocess.Popen(cmd, env=self.env,\n                                            close_fds=platform.system() != 'Windows',\n                                            stdout=self.log_file,\n                                            stderr=self.log_file,\n                                            stdin=PIPE)\n        except TypeError:\n            raise\n        except OSError as err:\n            if err.errno == errno.ENOENT:\n                raise WebDriverException(\n                    \"'%s' executable needs to be in PATH. %s\" % (\n>                       os.path.basename(self.path), self.start_error_message)\nE                       selenium.common.exceptions.WebDriverException: Message: 'chromedriver' executable needs to be in PATH. Please see https://sites.google.com/a/chromium.org/chromedriver/home\n\n/opt/hostedtoolcache/Python/3.7.13/x64/lib/python3.7/site-packages/selenium/webdriver/common/service.py:83: WebDriverException","flaky":false,"newFailed":false,"newBroken":true,"newPassed":false,"retriesCount":0,"retriesStatusChange":false,"beforeStages":[{"name":"cfg","time":{"start":1658375440129,"stop":1658375440129,"duration":0},"status":"passed","steps":[],"attachments":[],"parameters":[],"stepsCount":0,"attachmentsCount":0,"shouldDisplayMessage":false,"hasContent":false},{"name":"browser","time":{"start":1658375440129,"stop":1658375440132,"duration":3},"status":"broken","statusMessage":"selenium.common.exceptions.WebDriverException: Message: 'chromedriver' executable needs to be in PATH. Please see https://sites.google.com/a/chromium.org/chromedriver/home\n\n","statusTrace":"  File \"/opt/hostedtoolcache/Python/3.7.13/x64/lib/python3.7/site-packages/pluggy/callers.py\", line 187, in _multicall\n    res = hook_impl.function(*args)\n  File \"/opt/hostedtoolcache/Python/3.7.13/x64/lib/python3.7/site-packages/_pytest/fixtures.py\", line 1126, in pytest_fixture_setup\n    result = call_fixture_func(fixturefunc, request, kwargs)\n  File \"/opt/hostedtoolcache/Python/3.7.13/x64/lib/python3.7/site-packages/_pytest/fixtures.py\", line 925, in call_fixture_func\n    fixture_result = next(generator)\n  File \"/var/snap/amazon-ssm-agent/5656/actions-runner/_work/test-fw-ci/test-fw-ci/tests/conftest.py\", line 87, in browser\n    web_driver = webdriver.Chrome(options=options)\n  File \"/opt/hostedtoolcache/Python/3.7.13/x64/lib/python3.7/site-packages/selenium/webdriver/chrome/webdriver.py\", line 73, in __init__\n    self.service.start()\n  File \"/opt/hostedtoolcache/Python/3.7.13/x64/lib/python3.7/site-packages/selenium/webdriver/common/service.py\", line 83, in start\n    os.path.basename(self.path), self.start_error_message)\n","steps":[],"attachments":[],"parameters":[],"stepsCount":0,"attachmentsCount":0,"shouldDisplayMessage":true,"hasContent":true}],"afterStages":[],"labels":[{"name":"tag","value":"smoke"},{"name":"tag","value":"@pytest.mark.usefixtures('check_known_issues')"},{"name":"parentSuite","value":"tests.ui.auth"},{"name":"suite","value":"test_login"},{"name":"subSuite","value":"TestLogin"},{"name":"host","value":"ip-10-20-30-10"},{"name":"thread","value":"8339-MainThread"},{"name":"framework","value":"pytest"},{"name":"language","value":"cpython3"},{"name":"package","value":"tests.ui.auth.test_login"},{"name":"resultFormat","value":"allure2"}],"parameters":[{"name":"browser","value":"'chrome'"}],"links":[],"hidden":false,"retry":false,"extra":{"severity":"normal","retries":[],"categories":[{"name":"Test defects","matchedStatuses":[],"flaky":false}],"history":{"statistic":{"failed":0,"broken":1,"skipped":0,"passed":3,"unknown":0,"total":4},"items":[{"uid":"2c2f11023eff2a02","reportUrl":"https://bowiegan-jp.github.io/test-fw-ci/17//#testresult/2c2f11023eff2a02","status":"passed","time":{"start":1657877839029,"stop":1657877839640,"duration":611}},{"uid":"c6ccbf7b55cf9aba","reportUrl":"https://bowiegan-jp.github.io/test-fw-ci/16//#testresult/c6ccbf7b55cf9aba","status":"passed","time":{"start":1657875634722,"stop":1657875635526,"duration":804}},{"uid":"efe785859d552a60","reportUrl":"https://bowiegan-jp.github.io/test-fw-ci/15//#testresult/efe785859d552a60","status":"passed","time":{"start":1657875141329,"stop":1657875142687,"duration":1358}}]},"tags":["@pytest.mark.usefixtures('check_known_issues')","smoke"]},"source":"d0a7062ccf35f397.json","parameterValues":["'chrome'"]}